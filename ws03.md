<!-- markdownlint-disable MD005 MD012 MD013 MD007 MD024 -->

# COMP6991 Workshop 3

---

# Contents

1. Lifetimes
2. TermGame Library

---

# What are Lifetimes?


* A lifetime is a construct the compiler (or more specifically, its *borrow checker*) uses to ensure all borrows are valid.
* While *lifetimes* and *scopes* are often referred to together, **they are not the same**.
    * Scope refers to the accessibility/visibility of a variable.
    * Lifetime refers to the duration of borrowing of a variable.

---

# Lifetimes vs. scopes

```rust
fn main() {
    let i = 3;
    {
        let borrow1 = &i;
        println!("borrow1: {}", borrow1);
    }
    {
        let borrow2 = &i;
        println!("borrow2: {}", borrow2);
    }
}
```

## Answer the following questions

* What is happening in this code?
* What is the scope of `i`?
* What is the scope of `borrow1`?
* What is the scope of `borrow2`?
* What is the lifetime of `i`?
* What is the lifetime of `borrow1`?
* What is the lifetime of `borrow2`?

---

# Lifetimes vs. scopes

```rust
fn main() {
    let i = 3; // Scope of `i` starts. // Lifetime of `i` starts.
    {
        let borrow1 = &i; // Scope of `borrow1` starts. // Lifetime of 'borrow1' starts.
        println!("borrow1: {}", borrow1); // Lifetime of `borrow1` ends.
    } // Scope of `borrow1` ends.
    {
        let borrow2 = &i; // Scope of `borrow2` starts. // Lifetime of `borrow2` starts.
        println!("borrow2: {}", borrow2); // Lifetime of `i` ends. // Lifetime of `borrow2` ends.
    } // Scope of `borrow2` ends.
    // Scope of `i` ends.
}
```

## Takeaway

* Variable scope != Lifetimes.

---

# Temporality of borrowing


```rust
// Fails to compile.
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           // -+       |
    }                     //          |
                          //          |
    println!("r: {}", r); // ---------+
}
```

## Answer the following questions

* What is happening in this code?
* What are the lifetimes of `r` and `x`?
* Why doesn't this code compile?
* **Which line can I delete to make this compile?**

---

# The cheeky fix


```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           // -+-------|
    }
    // println!("r: {}", r);
}
```

* By deleting the `println!`, the borrow checker can see that `r` is not used in its own scope again so it will shorten its lifetime to the last point `r` is used.
    * This reiterates how lifetimes != scope.
* This behaviour by the borrow checker is referred to as the "temporality" of borrowing.
* Also known as **Non Lexical Lifetimes**, which was an idea introduced in 2018.
    * The pre-2018 version of the Rust compiler would not have compiled the above code.

---

# The "correct" fix


```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); // --+-------+
}
```

---

# Annotating lifetimes

* *Sometimes* when defining functions that borrow in Rust, the compiler will ask you to explicitly annotate your borrow types with lifetimes.

```rust
// Does not compile.
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let x = "Short";
    let y = "Loooooong";
    let str = longest(&x, &y);
    println!("{}", str);
}
```

---

# Annotating lifetimes

* Here is the syntax for annotating lifetimes in Rust.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let x = "Short";
    let y = "Loooooong";
    let str = longest(&x, &y);
    println!("{}", str);
}
```

---

```rust
fn prints_country(country_name: &str) -> &str {
    println!("{}", country_name);
    country_name
}


fn main() {
    let mut country = "Kiribati";

    country = prints_country(country);

    prints_country(country);
}
```
