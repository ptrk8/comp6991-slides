<!-- markdownlint-disable MD005 MD012 MD013 MD007 MD024 -->

# COMP6991 Workshop 5

---

# Contents

1. Polymorphism
2. Enums
3. Generics
4. Dynamic Dispatch

---

# Polymorphism


## Definition

> In programming language theory and type theory, polymorphism is the use of a single symbol to represent multiple different types.
\
In object-oriented programming, polymorphism is the provision of a single interface to entities of different types. The concept is borrowed from a principle in biology where an organism or species can have many different forms or stages.

*Source: Wikipedia*

---

# Enums

* Structs give you a way of grouping related fields and data.
* Enums give you a way of saying a value is one of a possible set of values.
* Rust supports "ad hoc polymorphism" through enums.

## Example

* The following enum establishes an `IpAddrKind` custom data type.

```rust
enum IpAddrKind {
    V4,
    V6,
}
/// fn main() {
/// }
```

* Now you can create concrete instances of the `IpAddrKind` type like so:

```rust
/// enum IpAddrKind {
///     V4,
///     V6,
/// }
/// fn main() {
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
/// }
```

* We can now define a function that takes any `IpAddrKind` and call it with either variant like so:

```rust
/// enum IpAddrKind {
///     V4,
///     V6,
/// }
fn route(ip_kind: IpAddrKind) {}

fn main() {
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}
```

---

# More on Enums

* You can also associate different types and amounts of data to each variant of an enum like so:

```rust
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}
/// fn main() {
/// }
```

* Just as you can define methods on structs using `impl`, you can also define methods on enums like so:

```rust
/// enum Shape {
///     Circle(f64),
///     Rectangle(f64, f64),
/// }
impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle(radius) => std::f64::consts::PI * radius * radius,
            Shape::Rectangle(width, height) => width * height,
        }
    }
}

fn main() {
    let c = Shape::Circle(1.0);
    println!("Circle Area: {}", c.area());
    let r = Shape::Rectangle(2.0, 3.0);
    println!("Rectangle Area: {}", r.area());
}
```

---

# Generics

* Rust supports "parametric polymorphism" through generics.
* Generics allowing **functions** or **data types** to be written without specifying concrete types.
* Below are familiar examples of generics in data types.

## `Option<T>`

```rust
enum Option<T> {
    Some(T),
    None,
}
/// fn main() {
/// }
```

## `Result<T, E>`

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
/// fn main() {
/// }
```

---

# Motivating Generics




---

# Summary

| Forms of Polymorphism      | Rust |
| :---------------- | :------: |
| Ad hoc polymorphism        | Enums, Operator Overloading |
| Parametric polymorphism    | Generics  |
| Subtyping                  | Traits  |

| Forms of Polymorphism      | Java |
| :---------------- | :------: |
| Ad hoc polymorphism        | Method Overloading, Method Overriding |
| Parametric polymorphism    | Generics |
| Subtyping                  | Inheritance, Interfaces |

| Forms of Polymorphism      | C++ |
| :---------------- | :------: |
| Ad hoc polymorphism        | Function Overloading, Operator Overloading |
| Parametric polymorphism    | Templates |
| Subtyping                  | Inheritance, Virtual Functions |

