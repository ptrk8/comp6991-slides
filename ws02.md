<!-- markdownlint-disable MD005 MD012 MD013 MD007 -->

# COMP6991 Workshop 2

---

# Contents

1. Introducing `Vec`.
2. Introducing `HashMap`.
3. Simple derive macros (`Copy`, `Clone`, `Debug`).
4. The purpose of the `serde` crate.

---

# What is a `Vec`?

* Short for "Vector".
* A Vector is a **dynamic array**.
* From the Rust docs:

> A contiguous growable array type with heap-allocated contents, written `Vec<T>`.
\
Vectors have O(1) indexing, amortized O(1) push (to the end) and O(1) pop (from the end).

---

# How to Initialise a `Vec`?

**Method 1:**

* Explicitly create a `Vec` with `Vec::new`.

```rust
/// fn main() {
let v: Vec<i32> = Vec::new();
///}
```

**Method 2:**

* Use the `vec!` macro.

```rust
/// fn main() {
let v: Vec<i32> = vec![];

let v = vec![1, 2, 3, 4, 5];

let v = vec![0; 10]; // ten zeroes

println!("{:?}", v);
///}
```

---

# How to Push to `Vec`?

* Pushing appends values onto the end of a vector (which will dynamically grow the vector as needed):

```rust
/// fn main() {
let mut v = vec![1, 2];

println!("{:?}", v);

v.push(3);

println!("{:?}", v);
///}
```

---

# How to Pop from `Vec`?

* Popping pops a value from the **end** of a vector.

```rust
/// fn main() {
let mut v = vec![1, 2];

println!("{:?}", v);

let two = v.pop();

println!("{:?}", v);
///}
```

---

# How to Index into `Vec`?

* Vectors also support indexing (through the `Index` and `IndexMut` traits):

```rust
/// fn main() {
let mut v = vec![1, 2, 3];

let three = v[2];

println!("{}", three);

v[1] = v[1] + 5;

println!("{:?}", v);

///}
```

---

# What is a `HashMap`?

* A key-value store that works like any other hash map.
* From the Rust docs:

> A hash map implemented with *quadratic probing* and *SIMD lookup*.

## Quadratic probing

* Minimises the *clustering problem*.
    * With linear probing, if there is a hash collision with the key and the next available slot is free, we insert our key/value pair there.
    * With quadratic probing, we use a quadratic function to calculate the next slot to probe.

## SIMD

* Stands for **Single Instruction, Multiple Data**.
* Speeds up lookup operations by processing multiple elements of the hash map simultaneously.
* Pretty much black magic.

## Takeaway

* Rust's standard library hash map implementation is *really* fast.

---

# How to Initialise a `HashMap`?

## Initialise empty `HashMap`

* Use `HashMap::new`.

```rust
/// fn main() {
use std::collections::HashMap;

let mut map: HashMap<String, i32> = HashMap::new();
///}
```

## Initialise with values

```rust
/// fn main() {
use std::collections::HashMap;

let map = HashMap::from([
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);

println!("{:?}", map);
///}
```

---

# How to Insert into `HashMap`?

* Call `.insert()` on the `HashMap`.

```rust
/// fn main() {
use std::collections::HashMap;

let mut book_reviews = HashMap::new();

// Review some books.
book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
book_reviews.insert(
    "Grimms' Fairy Tales".to_string(),
    "Masterpiece.".to_string(),
);

println!("{:?}", book_reviews);
///}
```

## Question

* Do you notice something interesting or "missing" in the declaration of `book_reviews`? ðŸ‘€

---

# Type Inference

## Answer

* An explicit type signature (`HashMap<String, String>`) is omitted from the declaration of `book_reviews`.
* **Type inference** refers to the compiler's ability to deduce the types of variables based on its usage and context.

```rust
/// fn main() {
use std::collections::HashMap;

let mut book_reviews = HashMap::new();

// Review some books.
book_reviews.insert(
    "Adventures of Huckleberry Finn".to_string(),
    "My favorite book.".to_string(),
);
book_reviews.insert(
    "Grimms' Fairy Tales".to_string(),
    "Masterpiece.".to_string(),
);

println!("{:?}", book_reviews);
///}
```

---

# Derive Macros

* The three derive macros we'll focus on are:
    * `Debug`
    * `Copy`
    * `Clone`

```rust
#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}
/// fn main() {

///}
```

---

# Motivating the `Debug` Derive Macro

* Say I define the following `struct` and I want to print it out.

```rust
struct Point {
    x: i32,
    y: i32,
}
/// fn main() {

let origin = Point { x: 0, y: 0 };

println!("{}", origin)
///}
```

* `println` has no idea *how* to format and print out the struct, so we get a compiler error.

---

# Solution

* Implement the `Debug` trait, which defines how the struct should be formatted when using the `{:?}` format specifier.
* **Rust traits** are conceptually identical to **Java interfaces** or **C++ virtual functions**.
* Now we can now print out our struct using the `{:?}` format specifier.

```rust
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Debug for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Point")
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}

/// fn main() {

let origin = Point { x: 0, y: 0 };

println!("{:?}", origin)
///}
```

---

# An Easier Solution

* However, implementing the `Debug` trait for every single struct you define is *tedious* and *verbose*.
* Rust gives us a way to automatically generate the previous boilerplate via **derive macros**.

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

/// fn main() {

let origin = Point { x: 0, y: 0 };

println!("{:?}", origin)
///}
```

---

# Motivating Copy vs. Owned types


* What do you expect to happen in the following code?

```rust
/// fn main() {
let x = 42;
let y = x;

println!("{y}");
println!("{x}");
///}
```

---

# What if we use a `String`?


* Now what do you expect to happen in the following code?

```rust
/// fn main() {
let x = String::from("Ownership!");
let y = x;

println!("{y}");
println!("{x}");
///}
```

---

# Why did that work for an `int` but not for a `String`?

* The reason is:
    * `int` is a **Copy** type
    * `String` is an **Owned** type

---

# What is a Copy type?

* Copy types are any "types that are easy to copy".
* Types that are easy to copy:
    1. Can be allocated on the Stack.
    2. The compiler knows their size at compile-time.
    3. Are generally small. E.g. less than or equal to the size of a register.
* Types that are natively Copy in Rust include:
    * integers
    * floats
    * booleans
    * chars
* If a type is Copy, the compiler will always copy the value when you send it to a function like so:

```rust
fn prints_number(number: i32) { // There is no -> so it's not returning anything
                             // If number was not copy type, it would take it
                             // and we couldn't use it again
    println!("{}", number);
}
/// fn main() {
let my_number = 8;
prints_number(my_number);
prints_number(my_number);
///}
```


