<!-- markdownlint-disable MD005 MD013 -->

# COMP6991 Workshop 2

---

# Contents:

* Introducing `Vec`.
* Introducing `HashMap`.
* Simple derive macros (`Copy`, `Clone`, `Debug`).
* The purpose of the `serde` crate.

---

# What is a `Vec`?

* Short for "Vector".
* A Vector is a **dynamic array**.
* From the Rust docs:

> A contiguous growable array type with heap-allocated contents, written `Vec<T>`.
\
Vectors have O(1) indexing, amortized O(1) push (to the end) and O(1) pop (from the end).

---

# How to Initialise a `Vec`?

**Method 1:**

* Explicitly create a `Vec` with `Vec::new`.

```rust
/// fn main() {
let v: Vec<i32> = Vec::new();
///}
```

**Method 2:**

* Use the `vec!` macro.

```rust
/// fn main() {
let v: Vec<i32> = vec![];

let v = vec![1, 2, 3, 4, 5];

let v = vec![0; 10]; // ten zeroes

println!("{:?}", v);
///}
```

---

# How to Push to `Vec`?

* Pushing appends values onto the end of a vector (which will dynamically the vector as needed):

```rust
/// fn main() {
let mut v = vec![1, 2];

println!("{:?}", v);

v.push(3);

println!("{:?}", v);
///}
```

---

# How to Pop from `Vec`?

* Popping pops a value from the **end** of a vector.

```rust
/// fn main() {
let mut v = vec![1, 2];

println!("{:?}", v);

let two = v.pop();

println!("{:?}", v);
///}
```

---

# How to Index into `Vec`?

* Vectors also support indexing (through the `Index` and `IndexMut` traits):

```rust
/// fn main() {
let mut v = vec![1, 2, 3];

let three = v[2];

println!("{}", three);

v[1] = v[1] + 5;

println!("{:?}", v);

///}
```

---

# What is a `HashMap`?

* A key-value store that works like any other Hashmap.
* From the Rust docs:

> A hash map implemented with *quadratic probing* and *SIMD lookup*.

